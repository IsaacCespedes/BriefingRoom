# Agent Best Practices

This document outlines the best practices for AI agents working on software development tasks. The goal is to ensure maintainability, safety, and developer velocity.

See [TECHNOLOGY-BEST-PRACTICES.md](./TECHNOLOGY-BEST-PRACTICES.md) for technology-specific best practices.

---

## Context7 Library IDs

When using Context7 to fetch documentation, use the following recommended library IDs:

-   **SvelteKit:** `/sveltejs/kit` (Official SvelteKit framework, 363 code snippets, benchmark score: 85.9)
-   **FastAPI:** `/websites/fastapi_tiangolo` (Official FastAPI documentation, 31,710 code snippets, benchmark score: 79.8)
-   **Tailwind CSS:** `/websites/v3_tailwindcss` (Tailwind CSS V3 documentation, 2,691 code snippets, benchmark score: 85.9)
-   **Supabase:** `/websites/supabase` (Official Supabase platform, 24,239 code snippets, benchmark score: 85.6)
-   **CrewAI:** `/crewaiinc/crewai` (Official CrewAI framework, 3,270 code snippets, benchmark score: 95.8)

---

## Serena MCP for Semantic Code Analysis

Serena MCP is available for advanced semantic code retrieval and editing capabilities. **Always prefer Serena's tools over basic file operations when working with source code.**

### When to Use Serena

-   **Exploring codebases**: Use symbolic tools to understand code structure without reading entire files
-   **Finding code**: Use `find_symbol` to locate classes, functions, or methods by name
-   **Understanding relationships**: Use `find_referencing_symbols` to see where code is used
-   **Editing code**: Use symbol-based editing tools (`replace_symbol_body`, `insert_after_symbol`, `insert_before_symbol`) for precise modifications
-   **Pattern search**: Use `search_for_pattern` for flexible regex-based searches when you don't know symbol names

### Key Principles

1. **Avoid reading entire source files** unless absolutely necessary. Use `get_symbols_overview` first to understand file structure.
2. **Work incrementally**: Get an overview → identify relevant symbols → read only what you need → edit precisely.
3. **Use symbolic editing** when replacing entire functions, classes, or methods. Use file-based editing only for small changes within large symbols.
4. **Understand before editing**: Use `find_referencing_symbols` to ensure changes don't break existing code.
5. **Symbol identification**: Symbols are identified by `name_path` (e.g., `MyClass/my_method`) and `relative_path`.

### Example Workflow

```
1. Overview:    mcp__serena__get_symbols_overview → See all top-level symbols
2. Find:        mcp__serena__find_symbol → Locate specific symbol with details
3. References:  mcp__serena__find_referencing_symbols → Check usage
4. Edit:        mcp__serena__replace_symbol_body → Precisely modify code
```

### Notes

-   Serena has indexed this project for Python and TypeScript
-   Project memories are stored in `.serena/memories/` with context about the project
-   Use `mcp__serena__list_memories` to see available project context
-   Serena runs a monitoring dashboard at http://localhost:8765 (default)

---

## Playwright MCP for Browser Automation

Playwright MCP provides comprehensive browser automation capabilities for testing, web scraping, and automated workflows.

### When to Use Playwright

-   **Testing web applications**: Automated testing of frontend applications
-   **Web scraping**: Extract data from websites programmatically
-   **Screenshots and snapshots**: Capture visual or accessibility snapshots of pages
-   **Form automation**: Fill and submit web forms automatically
-   **Multi-page workflows**: Navigate complex web workflows across multiple pages

### Key Capabilities

1. **Navigation**: Open URLs, navigate back/forward, manage multiple tabs
2. **Interaction**: Click elements, type text, fill forms, hover, drag & drop
3. **Inspection**: Take screenshots, capture accessibility snapshots, evaluate JavaScript
4. **Monitoring**: Track console messages, network requests, handle browser dialogs
5. **File Operations**: Upload files through web forms

### Common Operations

```
# Navigate and capture
mcp__playwright__browser_navigate → Open a URL
mcp__playwright__browser_snapshot → Get accessibility tree of page
mcp__playwright__browser_take_screenshot → Capture visual screenshot

# Interact with page
mcp__playwright__browser_click → Click on elements
mcp__playwright__browser_type → Type into input fields
mcp__playwright__browser_fill_form → Fill multiple form fields at once

# Monitor and debug
mcp__playwright__browser_console_messages → View console logs
mcp__playwright__browser_network_requests → Inspect network activity
```

### Best Practices

-   Always take a snapshot before interacting to understand page structure
-   Use accessibility tree snapshots (not screenshots) for determining what to click
-   Wait for content to load before taking actions
-   Handle dialogs and pop-ups appropriately
-   Close the browser when done to free resources

---

## Chrome DevTools MCP for Browser Control

Chrome DevTools MCP provides direct Chrome browser control and debugging capabilities, offering lower-level access than Playwright.

### When to Use Chrome DevTools

-   **Live debugging**: Debug web applications in real-time
-   **Performance analysis**: Analyze page performance and loading times
-   **Device emulation**: Test responsive designs with different viewport sizes
-   **Network throttling**: Test under different network conditions
-   **JavaScript execution**: Run custom JavaScript in browser context

### Key Capabilities

1. **Browser Control**: Navigate, resize, manage tabs and pages
2. **Element Interaction**: Click, hover, drag, type with precise control
3. **Performance**: Monitor performance metrics and traces
4. **Network**: Track requests, emulate network conditions
5. **Emulation**: Emulate devices, geolocation, and CPU throttling

### Common Operations

```
# Page management
mcp__chrome-devtools__navigate_page → Navigate to URL
mcp__chrome-devtools__new_page → Open new tab
mcp__chrome-devtools__list_pages → View all open tabs
mcp__chrome-devtools__select_page → Switch between tabs

# Interaction
mcp__chrome-devtools__click → Click elements
mcp__chrome-devtools__fill → Fill form fields
mcp__chrome-devtools__take_snapshot → Capture page state

# Debugging
mcp__chrome-devtools__evaluate_script → Execute JavaScript
mcp__chrome-devtools__get_console_message → Read console logs
mcp__chrome-devtools__get_network_request → Inspect network calls

# Emulation
mcp__chrome-devtools__emulate → Set device/network conditions
mcp__chrome-devtools__resize_page → Change viewport size
```

### Best Practices

-   Take snapshots to understand page structure before interactions
-   Use emulation to test different devices and network conditions
-   Monitor console and network for debugging
-   Clean up by closing pages when done
-   Use performance tools to identify bottlenecks

### Playwright vs Chrome DevTools

-   **Use Playwright** for: Standard web testing, form automation, cross-browser testing
-   **Use Chrome DevTools** for: Chrome-specific debugging, performance analysis, advanced emulation

---

## GitHub MCP for Repository Management

GitHub MCP provides comprehensive GitHub API integration for managing repositories, issues, pull requests, and more.

### When to Use GitHub MCP

-   **Repository operations**: Create/fork repositories, manage branches, search code
-   **Issue management**: Create, update, list, and search issues with labels and comments
-   **Pull request workflows**: Create PRs, add reviews, merge changes, request reviews
-   **Code collaboration**: Manage teams, assign tasks, track project progress
-   **Release management**: Create and manage releases and tags
-   **Advanced search**: Search across code, issues, PRs, repositories, and users

### Key Capabilities

1. **Repository Management**: Create repos, branches, manage files, view commits
2. **Issues**: Full CRUD operations, comments, labels, sub-issues, issue types
3. **Pull Requests**: Create, update, review, merge, request reviews, view diffs
4. **Code Operations**: Create/update/delete files, push multiple files, search code
5. **Collaboration**: Team management, assignees, reviewers, GitHub Copilot integration

### Common Operations

```
# Repository operations
mcp__github__create_repository → Create new repository
mcp__github__create_branch → Create new branch
mcp__github__list_branches → List all branches
mcp__github__search_repositories → Find repositories

# Issues
mcp__github__issue_write → Create or update issues
mcp__github__issue_read → Get issue details and comments
mcp__github__search_issues → Search issues with filters
mcp__github__add_issue_comment → Add comments to issues

# Pull Requests
mcp__github__create_pull_request → Create new PR
mcp__github__pull_request_read → Get PR details, diffs, reviews
mcp__github__update_pull_request → Update PR properties
mcp__github__merge_pull_request → Merge approved PR
mcp__github__pull_request_review_write → Create/submit reviews

# Files and Commits
mcp__github__create_or_update_file → Create/update single file
mcp__github__push_files → Push multiple files in one commit
mcp__github__get_file_contents → Read file or directory contents
mcp__github__list_commits → Get commit history

# Search
mcp__github__search_code → Search code across all repositories
mcp__github__search_pull_requests → Find PRs with filters
mcp__github__search_users → Find GitHub users
```

### Best Practices

-   Always use `get_me` to verify authentication before operations
-   Use search tools before creating issues to avoid duplicates
-   Check for PR templates in `.github/PULL_REQUEST_TEMPLATE` before creating PRs
-   Use `list_issue_types` for organizations with custom issue types
-   Create pending reviews first, add comments, then submit reviews for complex PR feedback
-   Use conventional commit messages when pushing files
-   Leverage GitHub Copilot integration for code reviews

### Authentication

-   **Status**: ✅ Authenticated as @IsaacCespedes
-   **Token Type**: GitHub Personal Access Token
-   **Configuration**: Stored in `.claude.json` under BriefingRoom project

---

## Supabase MCP for Backend Operations

Supabase MCP provides comprehensive integration with Supabase platform for database operations, Edge Functions, branches, and project management.

### When to Use Supabase MCP

-   **Database operations**: Execute SQL, apply migrations, manage tables and extensions
-   **Edge Functions**: Deploy and manage Deno-based serverless functions
-   **Development branches**: Create isolated development environments with branching
-   **Project management**: Create projects, manage organizations, monitor resources
-   **Debugging**: View logs, check advisors, analyze performance
-   **Type generation**: Generate TypeScript types from database schema

### Key Capabilities

1. **Database Management**: Tables, extensions, migrations, SQL execution
2. **Edge Functions**: Deploy, list, and retrieve Deno-based functions
3. **Branching**: Create development branches with isolated databases
4. **Monitoring**: Logs, advisors (security/performance), project status
5. **Type Safety**: Generate TypeScript types from schema
6. **Documentation**: Search Supabase docs with GraphQL

### Common Operations

```
# Project Management
mcp__supabase__list_projects → List all projects
mcp__supabase__get_project → Get project details
mcp__supabase__create_project → Create new project (requires cost confirmation)
mcp__supabase__list_organizations → List organizations

# Database Operations
mcp__supabase__list_tables → List tables in schemas
mcp__supabase__execute_sql → Run SQL queries
mcp__supabase__apply_migration → Apply DDL migrations
mcp__supabase__list_migrations → View migration history
mcp__supabase__list_extensions → List installed extensions

# Edge Functions
mcp__supabase__deploy_edge_function → Deploy function with files
mcp__supabase__list_edge_functions → List all functions
mcp__supabase__get_edge_function → Get function source code

# Development Branches
mcp__supabase__create_branch → Create development branch
mcp__supabase__list_branches → List all branches
mcp__supabase__merge_branch → Merge branch to production
mcp__supabase__reset_branch → Reset branch migrations
mcp__supabase__rebase_branch → Rebase branch on production

# Debugging & Monitoring
mcp__supabase__get_logs → Get service logs (api, postgres, auth, etc.)
mcp__supabase__get_advisors → Check security/performance advisories
mcp__supabase__generate_typescript_types → Generate types from schema

# Configuration
mcp__supabase__get_project_url → Get API URL
mcp__supabase__get_publishable_keys → Get API keys (anon/publishable)
mcp__supabase__search_docs → Search Supabase documentation
```

### Best Practices

-   **Always use migrations** for DDL operations via `apply_migration`, not `execute_sql`
-   **Check costs first**: Use `get_cost` and `confirm_cost` before creating projects/branches
-   **Run advisors regularly**: Especially after schema changes to catch missing RLS policies
-   **Use branches**: Create development branches for testing schema changes
-   **Type generation**: Generate TypeScript types after schema changes for type safety
-   **Monitor logs**: Use `get_logs` to debug issues across different services
-   **Avoid hardcoded IDs**: Don't reference generated IDs in data migrations
-   **Security first**: Always enable RLS policies for tables with user data

### Authentication

-   **Status**: ✅ Authenticated
-   **Organization**: IsaacCespedes's Org (uvirrgiqyqgqonqjlwsb)
-   **Token Type**: Supabase Personal Access Token
-   **Configuration**: HTTP-based MCP with bearer token authentication

### Documentation Search

The Supabase MCP includes GraphQL-based documentation search:
- Search by topic for guides and API references
- Filter by language (JavaScript, Python, Swift, Dart, C#, Kotlin)
- Access CLI commands, Management API, and client library documentation
- Query error codes and troubleshooting guides

---

## 1. Before Coding

-   **Ask Clarifying Questions (MUST):** Always ask clarifying questions on complex tasks or architecture prior to coding to ensure you are entirely sure of what to do.
-   **Spec-Driven Development (MUST):** Follow a spec-driven development process:
    1.  **Documentation & Diagrams:** Begin by creating or updating documentation, including diagrams (Flow Charts, Component Diagrams, System Architecture, ERDs) to solidify the plan.
    2.  **Tests:** Write failing tests that define the desired functionality.
    3.  **Code:** Implement the code to make the tests pass.
-   **Check for Existing Docs (MUST):** Always check for existing documentation before starting a new task.
-   **Check for Conventions (MUST):** Analyze the existing codebase to ensure consistency in style, patterns, and conventions.
-   **Draft Approach (SHOULD):** For complex work, draft and confirm your approach. If multiple options exist, list their pros and cons.

## 2. While Coding

-   **Test-Driven Development (SHOULD):** Follow TDD when practical: scaffold a stub -> write a failing test -> implement the code.
-   **Consistent Naming (MUST):** Use the existing domain vocabulary for naming functions, variables, and classes.
-   **Consistent Style (MUST):** Adhere to the established code style of the project.
-   **Modularity (SHOULD):** Prefer modular code over monolithic code. Break down complex functionality into smaller, focused modules.
-   **Simplicity (SHOULD NOT):** Avoid creating new abstractions (e.g., classes, traits) when simpler functions would suffice.
-   **Self-Explanatory Code (SHOULD NOT):** Rely on clean, self-explanatory code instead of comments. Only add comments for critical caveats.
-   **Robust Error Handling (MUST):** Implement proper error handling. For APIs, return appropriate HTTP status codes.
-   **Leverage the Type System (SHOULD):** Use the type system to enforce correctness and prevent runtime errors.

## 3. Testing

-   **Unit Test Location (MUST):** Follow the established conventions for unit test location for the language and project. For example, some languages prefer tests in the same file, while others prefer separate test files in a dedicated test directory. For larger projects, follow the established testing structure.
-   **Integration Tests (MUST):** Add or extend integration tests for any change to an API endpoint.
-   **Separate Test Types (MUST):** Keep pure-logic unit tests separate from integration tests that interact with databases, networks, or file systems.
-   **Prefer Integration Tests (SHOULD):** Prefer integration tests over extensive mocking.
-   **Test All Paths (SHOULD):** Write tests for error conditions and edge cases, not just the "happy path."

## 4. Database

-   **Prevent SQL Injection (MUST):** Use an ORM, query builder, or parameterized queries. Never use string formatting to build SQL queries.
-   **Use Migrations (MUST):** All schema changes must be managed through migration files.
-   **Appropriate Data Types (SHOULD):** Use database column types that are appropriate for the data being stored.

## 5. Code Organization

-   **Logical Separation (MUST):** Keep frontend and backend code in separate, clearly defined directories.
-   **Group by Feature/Module (SHOULD):** Group related functionality into modules (e.g., `auth`, `services`, `utils`).
-   **Thin Route Handlers (MUST):** Keep API route handlers minimal. Delegate all business logic to a service layer.

## 6. Security

-   **Validate All Inputs (MUST):** Never trust client-provided data. Validate all inputs on the server side.
-   **Sanitize User Content (MUST):** Sanitize user-generated content before storing or displaying it to prevent XSS attacks.
-   **Verify Authentication/Authorization (MUST):** Secure all protected endpoints by verifying authentication and authorization.
-   **Manage Secrets (MUST):** Store all secrets (API keys, passwords) in environment variables, never in the code.
-   **Use HTTPS (MUST):** Use HTTPS in production environments.

## 7. Git & Version Control

-   **Conventional Commits (MUST):** Use the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) format for all commit messages.
-   **No Agent References (SHOULD NOT):** Do not refer to the AI agent (e.g., Gemini, Claude) in commit messages.

## 8. User Interaction

-   **Audible Notifications (MUST):** Use the `say` command to notify the user of task completion or when input is required.
    -   Example on completion: `say "Task completed."`
    -   Example when waiting for input: `say "Input required."`